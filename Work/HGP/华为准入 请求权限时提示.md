## 描述
华为应用市场的准入规则要求app在向用户请求权限时，需要以弹窗等形式提示用户请求该权限的用途，类似下图。
![[Pasted image 20240130170245.png]]

## 参考链接
https://en.uniapp.dcloud.io/api/system/create-request-permission-listener.html
https://blog.csdn.net/m0_73358221/article/details/133906138
https://blog.csdn.net/wz9608/article/details/135202285
https://blog.csdn.net/csdnxxxjjjqqq/article/details/127144435

## 实现：扫码请求摄像头权限
uniapp官方的解决方案`createRequestPermissionListener`需要Hbuilder4.0+。
以下是4.0-的解决方案。
1. 由于无法实时监听请求权限弹窗，所以提示弹窗需要在请求权限之前出现。
2. H5环境无需请求权限。
3. 点击扫码图标 => 判断当前环境 => APP环境时判断是否拥有该权限 => 无权限时打开提示弹窗，再主动发起请求 => 授权，则扫码；无授权，则中止流程。

#### 提示弹窗
1. 在工云链H5项目里面，由于存在原生和自定义两种导航栏，所以需要判断当前页面的导航栏类型后动态修改top值。
2. 这两种导航栏的差别在于弹窗打开后位置不同。弹窗位置在原生导航栏下方，两者不会重叠；但会覆盖自定义导航栏。
```html
<!-- 扫码组件 -->
<template>
  <!-- ... -->
  <!-- 提示弹窗 -->
    <hgpPopup ref="permissionAlertPopup" type="top">
      <view class="permission-alert" :style="`top: ${permissionAlertTop}`">
        <view style="font-size: 20px;margin-bottom: 20rpx">摄像头权限使用说明</view>
        <view style="color: darkgray">用于向您提供订单、工单等条码扫一扫等服务</view>
      </view>
		</hgpPopup>
	</view> 
</template>

<style lang="scss">
	.permission-alert {
		width: 90vw;
		background-color: #fff;
		margin: auto;
		position: absolute;
		padding: 30rpx;
    left: 0;
    right: 0;
		z-index: 999;
		border-radius: 40rpx;
    line-height: 1.5em;
	}
</style>
```
```js
getHeight(){
  uni.getSystemInfo({
    success: (e) => {
      const safeAreaTop = e.safeArea.top
      // 安全区域大于0，说明启用了自定义导航栏
      const isNavCustom = safeAreaTop > 0
      this.permissionAlertTop = isNavCustom ? '70rpx' : '30rpx'
    }
  })
},
```

#### 判断是否拥有某权限
```js
checkPermission(authorization){
  let compat = plus.android.importClass('androidx.core.content.ContextCompat')
  let context = plus.android.runtimeMainActivity()
  let result = compat.checkSelfPermission(context, authorization)
  // 0: 该权限已获授权
  return result === 0
},
```

#### 主动请求某权限
简单地用Promise包装一下。
```js
  // authorizations 请求的权限数组
  // authorization 需要返回请求结果的权限名称
  requestPermission(authorizations, authorization) {
    return new Promise((resolve, reject) => {
      plus.android.requestPermissions(
        authorizations, 
        (resultObj) => {
          let res = false
          for (let i = 0; i < resultObj.granted.length; i++) {
            let grantedPermission = resultObj.granted[i];
            if(grantedPermission === authorization){
              res = true
            }
          }
          resolve(res)
        }), 
        (e) => {
          reject(e)
        }
      })
  },
```

## 结果示例：工云链H5 扫码请求摄像头权限
```vue
<template>
	<view id="hgpScan" @click.stop="preScan">
    <hgpPopup ref="permissionAlertPopup" type="top">
      <view class="permission-alert" :style="`top: ${permissionAlertTop}`">
        <view style="font-size: 20px;margin-bottom: 20rpx">摄像头权限使用说明</view>
        <view style="color: darkgray">用于向您提供订单、工单等条码扫一扫等服务</view>
      </view>
		</hgpPopup>
    <slot>
      <text class="iconfont icon-saoma"></text>
    </slot>
	</view> 
</template>

<script>
  import hgpPopup from '@/components/hgp-popup/hgp-popup.vue';
	export default {
		name: "hgpScan",
		components: {hgpPopup},
		data() {
			return {
        permissionAlertTop: '40rpx',
        permission: "android.permission.CAMERA"
      }
		},
		mounted() {
			this.getWechatConfig()
		},
		methods: {
      /* 由于自定义导航栏，需要动态改变弹窗的高度 */
      getHeight(){
        uni.getSystemInfo({
          success: (e) => {
            const safeAreaTop = e.safeArea.top
            // 安全区域大于0，说明启用了自定义导航栏
            const isNavCustom = safeAreaTop > 0
            this.permissionAlertTop = isNavCustom ? '70rpx' : '30rpx'
          }
        })
      },
      /* 检查是否有权限 */
      checkPermission(authorization){
        let compat = plus.android.importClass('androidx.core.content.ContextCompat')
        let context = plus.android.runtimeMainActivity()
        let result = compat.checkSelfPermission(context, authorization)
        // 0: 该权限已获授权
        return result === 0
      },
      /* 发起权限请求并返回结果 */
			requestPermission(authorizations, authorization) {
        this.getHeight()
        return new Promise((resolve, reject) => {
          plus.android.requestPermissions(
            authorizations, 
            (resultObj) => {
              let res = false
              for (let i = 0; i < resultObj.granted.length; i++) {
                let grantedPermission = resultObj.granted[i];
                if(grantedPermission === authorization){
                  res = true
                }
              }
              resolve(res)
            }), 
            (e) => {
              reject(e)
				    }
          })
			},
			getWechatScanningKey() {
				let req = getWechatScanningKey().then(res => {
					return res
				})
				return req
			},
			async getWechatConfig() {
				let req = await this.getWechatScanningKey()
				if (req.success) {
					let apiUrl = location.href.split("#")[0]
					let params = {
						apiUrl,
						scanningKey: req.data
					}
					getWechatConfig(params).then(res => {
						if (res.success) {
							this.wx_sanCode(res.entity)
						}
					})
				}
			},
			preScan() {
        if (this.disabled) return
        //#ifdef APP-PLUS
        const permitted = this.checkPermission(this.permission)
        if(!permitted){
          this.$refs.permissionAlertPopup.open()
          this.requestPermission(
            [ this.permission ],
            this.permission 
          ).then((res) => {
            this.$refs.permissionAlertPopup.close()
            if(res)this.scan()
          }).catch(() => {
            this.$refs.permissionAlertPopup.close()
          })
          // app无权限则去请求权限，这里直接return
          return
        }
        //#endif
        // app有权限时进入scan；H5直接进入scan
        this.scan()
			},
      scan(){
        this.$emit('scanBegin')
				let _this = this;
				//#ifdef APP-PLUS
				_this.$mpaasScanModule.mpaasScan({
						// 扫码识别类型，参数可多选，qrCode、barCode，不设置，默认识别所有
						'scanType': ['qrCode', 'barCode'],
						// 是否隐藏相册，默认false不隐藏
						'hideAlbum': false
					},
					(res) => {
						_this.analysScan(res.resp_result);
					})
				//#endif

				//#ifdef H5
				this.bindsaoQRcode();
				//#endif
      },
			wx_sanCode(wxData) {
				let _this = this;
				_this.$jWeixin.config({
					debug: false, // 开启调试模式,调用的所有api的返回值会在客户端alert出来，若要查看传入的参数，可以在pc端打开，参数信息会通过log打出，仅在pc端时才会打印。
					appId: wxData.appId, // 必填，公众号的唯一标识
					timestamp: wxData.timestamp, // 必填，生成签名的时间戳
					nonceStr: wxData.noncestr, // 必填，生成签名的随机串
					signature: wxData.signature, // 必填，签名
					jsApiList: ['scanQRCode'] // 必填，需要使用的JS接口列表
				})
				_this.$jWeixin.ready(function() {
					// config信息验证后会执行ready方法，所有接口调用都必须在config接口获得结果之后，config是一个客户端的异步操作，所以如果需要在页面加载时就调用相关接口，则须把相关接口放在ready函数中调用来确保正确执行。对于用户触发时才调用的接口，则可以直接调用，不需要放在ready函数中。
					_this.$jWeixin.checkJsApi({
						jsApiList: ['scanQRCode'], // 需要检测的JS接口列表，所有JS接口列表见附录2,
						success: function(res) {
							console.log(res)
							// 以键值对的形式返回，可用的api值true，不可用为false
							// 如：{"checkResult":{"chooseImage":true},"errMsg":"checkJsApi:ok"}
						}
					});
				});
				_this.$jWeixin.error(function(res) {
					// config信息验证失败会执行error函数，如签名过期导致验证失败，具体错误信息可以打开config的debug模式查看，也可以在返回的res参数中查看，对于SPA可以在这里更新签名。
					console.log(res, '接口验证失败')
				});

			},
			bindsaoQRcode() {
				let _this = this;
				_this.$jWeixin.scanQRCode({
					needResult: 1, // 默认为0，扫描结果由微信处理，1则直接返回扫描结果，
					scanType: ["qrCode", "barCode"], // 可以指定扫二维码还是一维码，默认二者都有
					success: function(res) {
						var result = res.resultStr; // 当needResult 为 1 时，扫码返回的结果
						// window.location.href = result //安卓机型跳转渲染有问题 所以要加这句
						if (!result) {
							uni.showToast({
								icon: 'none',
								title: "二维码无效！",
								duration: 4000
							})
						}
						_this.analysScan(result);
					}
				});
			},
			analysScan(data) {
        // 后端解析
			}
		}
	};

</script>

<style lang="scss">
	.permission-alert {
		width: 90vw;
		background-color: #fff;
		margin: auto;
		position: absolute;
		padding: 30rpx;
    left: 0;
    right: 0;
		z-index: 999;
		border-radius: 40rpx;
    line-height: 1.5em;
	}
</style>
```